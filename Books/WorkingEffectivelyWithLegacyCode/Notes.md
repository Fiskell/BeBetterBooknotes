About the book
======
Why I chose the book
======
Notes
======

Preface
------

> I bought a C compiler

This was a fun fact to me because I didn't know that compiles ever cost money.

> I asked him, "How are they doing?" He said, "They're writing legacy code, man."

I have worked in codebases that were 'legacy' codebases.  But I have never thought
of the act of writing code to be adding more legacy code.  There is always the idea
of good and bad ways of writing code, but to refer to freshly typed code as 'legacy' has a much
more visceral feel.

> They are trying very hard, but at the end of the day, because of schedule pressure, the weight of history,
or a lack of any better code to compare their efforts to, many people are writing legacy code.

I often refer to this as learned helplessness.  It is hard to do something better 
if you don't know what you are doing wrong, or if you are okay with the current situation.

> To me, legacy code is simply code without tests.

This is an extremely powerful statement that I have already stolen and used.

> Code without tests is bad code. It doesn't matter how well written it is; 
it doesn't matter how pretty or object-oriented or well encapsulated it is. 
With tests, we can change the behavior of our code quickly and verifiably. 
Without them, we really don't know if our code is getting better or worse.

After reading this I immediately jumped into my current codebase and started
writing tests for the code I considered to be 'good'. Now it is.

Chapter 1: Changing Software
-------

> Four reasons to change software:
1) Adding a feature
2) Fixing a bug
3) Improving the design
4) Optimizing resource usage


> In poorly structured code, the move from figuring things out to making changes 
feels like jumping off a cliff to avoid a tiger.  You hesitate and hesitate.  
"Am I ready to do it? Well, I guess I have to."

This is a perfectly put analogy to the emotion that I face for larger features being deployed.

Chapter 2: Working with Feedback
------


